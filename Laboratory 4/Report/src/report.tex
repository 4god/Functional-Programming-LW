% !TEX root = main.tex

\section{Чем принципиально отличаются функции \texttt{CONS}, \texttt{LIST}, \texttt{APPEND}}

Пусть
\begin{lstlisting}
(setf lst1 '(a b))
(setf lst2 '(c d))
\end{lstlisting}
Тогда при использовании \verb|CONS|
\begin{lstlisting}
(cons lst1 lst2) => ((A B) C D) 
\end{lstlisting}
Таким образом \verb|CONS| создаёт \textit{списочную ячейку}, у которой \textit{car-указатель} указывает на первый аргумент, а \textit{cdr-указатель} --- на второй.
При использовании \verb|LIST|
\begin{lstlisting}
(list lst1 lst2) => ((A B) (C D)) 
\end{lstlisting}
Получаем, что \verb|LIST| гарантирует возвращение нового \textit{списка} из элементов, переданных функции в качестве аргументов.
При использовании \verb|APPEND|
\begin{lstlisting}
(append lst1 lst2) => (A B C D)
\end{lstlisting}
\verb|APPEND| возвращает новый список, который формируется из объединения списков переданных функции в качестве аргументов. При этом последний аргумент может являться не списком. \verb|CDR| указатель нового списка будет указывать как раз на последний аргумент.


\section{Вычислить результат выражения}

\problem \hfill

\begin{lstlisting}
(reverse ()) => NIL
\end{lstlisting}


\problem \hfill

\begin{lstlisting}
(last ()) => NIL
\end{lstlisting}


\problem \hfill

\begin{lstlisting}
(reverse '(a)) => (A)
\end{lstlisting}


\problem \hfill

\begin{lstlisting}
(last '(a)) => 
\end{lstlisting}


\problem \hfill

\begin{lstlisting}
(reverse '((a b c))) => ((A B C))
\end{lstlisting}


\problem \hfill

\begin{lstlisting}
(last '((A B C))) => ((A B C))
\end{lstlisting}



\section{Написать функцию}

\problem Функции, которые возвращают последний элемент своего списка-аргумента

\biglisting{../../Problems/src/problem-3-1.lisp}


\problem Функции, которые возвращают свой список-аргумент без последнего элемента

\biglisting{../../Problems/src/problem-3-2.lisp}



\section{Написать программу}

\problem Простой вариант игры в кости, в которой бросаются две правильные кости. Если сумма выпавших очков равна $7$ или $11$ --- выигрыш, если выпало $(1, 1)$ или $(6, 6)$ --- игрок получает право снова бросить кости, во всех остальных случаях ход переходит ко второму игроку, но запоминается сумма выпавших очков. Если второй игрок не выигрывает абсолютно, то выигрывает тот игрок, у которого больше очков.

\newpage
\biglisting{../../Problems/src/problem-4.lisp}



\section{Заключение}

В данной лабораторной работе был проведён анализ различия между \verb|CONS|, \verb|LIST| и \verb|APPEND|. Так же были изучены мнемонические альтернативы \verb|CAR| и \verb|CDR|. На основе решения последней задачи было изучено написание более сложных функций, которые могут иметь необязательные параметры, а так же установка для них значений по умолчанию.
